---
title: "Floyd-Warshall 알고리즘"

categories:
- Algorithm

tags:
- Algorithm
---

# Floyd-Warshall 알고리즘

모든 노드에서 다른 모든 노드로 가는 최단 경로를 찾는 알고리즘      
출발점 + 거쳐가는 노드 + 도착점 < 출발점 + 도착점 이면 업데이트를 한다. 

![image](https://github.com/kit-teamcook-2023/teamcook-front/assets/63646062/156b3669-e81a-49a3-832b-8adfd7d8412f)


- 거쳐가는 노드가 mid이고 이 값을 기준으로 업데이트 하므로 mid 변수가 가장 바깥에 온다.
- 이후 start, end로 부터 기존 값과 거쳐갔을 때의 값을 비교후 최소 값을 넣는다
```java
for(int mid = 0; mid < n; mid++) {
    for(int start = 0; start < n; start++) {
        for(int end = 0; end < n; end++) {
            if(graph[start][mid] + graph[mid][end] < graph[start][end]) {
               graph[start][end] = graph[start][mid] + graph[mid][end]
            }
        }
    }
}
```

* 초기상태

|   | 1   | 2   | 3   | 4   | 5   |
|---|-----|-----|-----|-----|-----|
| 1 | 0   | 3   | 7   | INF | INF |
| 2 | 3   | 0   | INF | 4   | INF |
| 3 | 7   | INF    | 0   | 5   | 1   |
| 4 | INF    | 4   | 5   | 0   | 2   |
| 5 |  INF   |  INF   | 1   | 2   | 0   |

<br>
<br>
* 1번 수행(1번 노드를 거쳐가는 경우 고려)

|   | 1   | 2   | 3   | 4   | 5   |
|---|-----|-----|-----|-----|-----|
| 1 | 0   | 3   | 7   | INF | INF |
| 2 | 3   | 0   | 10  | 4   | INF |
| 3 | 7   | 10  | 0   | 5   | 1   |
| 4 | INF    | 4   | 5   | 0   | 2   |
| 5 |  INF   | INF | 1   | 2   | 0   |

<br>
<br>
* 2번 수행(2번 노드를 거쳐가는 경우 고려)

|   | 1   | 2   | 3   | 4   | 5   |
|---|-----|-----|-----|-----|-----|
| 1 | 0   | 3   | 7   | INF | INF |
| 2 | 3   | 0   | 10  | 4   | INF |
| 3 | 7   | 10  | 0   | 5   | 1   |
| 4 | INF    | 4   | 5   | 0   | 2   |
| 5 |  INF   | INF | 1   | 2   | 0   |

<br>
<br>
* 최종 결과

|   | 1   | 2   | 3   | 4   | 5   |
|---|-----|-----|-----|-----|-----|
| 1 | 0   | 3   | 7   | 7   | 8   |
| 2 | 3   | 0   | 7   | 4   | 6   |
| 3 | 7   | 7   | 0   | 3   | 1   |
| 4 | 7   | 4   | 3   | 0   | 2   |
| 5 | 8   | 6   | 1   | 2   | 0   |

이렇게 최종 결과가 나오는데

**O(n³)** 이라는 시간복잡도를 가지는데 노드의 수가 많아지면 배열을 만드는 것도 문제고
시간이 엄청나게 걸려서 사용하는 데에 제약이 있다.

[프로그래머스 예시 문제](https://school.programmers.co.kr/learn/courses/30/lessons/49191#qna)

# 결론

그냥 다익스트라 알고리즘이 O(n²) 걸리는 이유가 한 정점에서 
다른 정점으로 가는 최단거리를 구하는거에 비해 이 알고리즘은 모든 정점이 다른 모든 정점으로 가는 알고리즘이라
그런지 모든 데이터가 필요한게 아니면 다익스트라 알고리즘을 사용하는게 나을 것 같다.


